<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>옆집 누나 어드벤처 (UI 전용 / 자동 진행)</title>
<style>
  :root{ --bg:#0f1115; --panel:#171a21; --ink:#e6ebff; --muted:#99a2c7; --accent:#6aa6ff; --accent-2:#7ef7c4; }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Apple SD Gothic Neo, "맑은 고딕", sans-serif;
    background:linear-gradient(180deg,#0b0d12,var(--bg)); color:var(--ink);
  }
  .wrap{ max-width:980px; margin:24px auto; padding:16px; display:grid; grid-template-columns:1.6fr 1fr; gap:16px; }
  @media (max-width:900px){ .wrap{grid-template-columns:1fr} }
  .card{ background:rgba(23,26,33,.75); border:1px solid rgba(255,255,255,.08); border-radius:14px; padding:16px; backdrop-filter: blur(6px); box-shadow:0 10px 28px rgba(0,0,0,.35); }
  h1{font-size:20px;margin:0 0 8px}
  #log{min-height:360px; max-height:65vh; overflow:auto; padding-right:6px; scroll-behavior:smooth}
  .line{margin:10px 0; display:flex; gap:8px}
  .speaker{font-weight:700; color:var(--accent); min-width:64px}
  .content{white-space:pre-wrap; line-height:1.7}
  .narr{color:var(--muted); font-style:italic}
  .choices{display:flex; flex-direction:column; gap:8px; margin-top:10px}
  .choice{
    background:#10131a; border:1px solid rgba(255,255,255,.12); color:#ffffff;
    padding:10px 12px; border-radius:10px; cursor:pointer;
    transition:transform .05s ease, border-color .15s, background .15s;
  }
  .choice:hover{ transform:translateY(-1px); border-color:var(--accent) }
  .topbar{display:flex; align-items:center; gap:10px; margin-bottom:8px; flex-wrap:wrap}
  .badge{font-size:12px; opacity:.8}
  .aff{ width:100%; height:10px; background:#0d1016; border-radius:999px; overflow:hidden; border:1px solid rgba(255,255,255,.08); }
  .aff>span{display:block; height:100%; width:0%; background:linear-gradient(90deg,var(--accent),var(--accent-2)); transition:width .35s ease}
  .hint{font-size:12px; color:var(--muted); margin-top:6px}
  .toolbar{display:flex; gap:8px; margin-top:10px; flex-wrap:wrap}
  .btn{ padding:8px 12px; border:1px solid rgba(255,255,255,.12); border-radius:10px; background:#111520; color:var(--ink); cursor:pointer }
  .btn:hover{border-color:var(--accent)}
  .pill{padding:3px 8px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); border-radius:999px; font-size:12px}
  .footer{opacity:.7; font-size:12px; margin-top:8px}
  input[type="file"]{display:none}
  label[for="file"]{ cursor:pointer }
  .levelTitle{font-weight:700; color:var(--accent-2); margin-bottom:6px}
  #levelText{white-space:pre-wrap; line-height:1.6}
</style>
</head>
<body>
<div class="wrap">
  <!-- 메인 패널 -->
  <section class="card">
    <div class="topbar">
      <h1>옆집 누나 어드벤처 (UI)</h1>
      <span class="pill">타자기 효과</span>
      <span class="badge">텍스트 클릭 = 즉시 스킵</span>
    </div>

    <div id="log" aria-live="polite"></div>

    <div class="toolbar">
      <button id="restart" class="btn">처음부터</button>
      <button id="fast" class="btn">타자 속도 토글</button>
      <input id="file" type="file" accept="application/json" />
      <label for="file" class="btn">시나리오 불러오기(JSON)</label>
    </div>
    <div class="footer">시나리오는 별도 <code>scenario.json</code>로 관리됩니다. (동일 폴더 자동 로딩/버튼으로 수동 로딩)</div>
  </section>

  <!-- 사이드 패널: 허용 스킨십 레벨 -->
  <aside class="card">
    <div class="levelTitle">허용 스킨십 레벨 (0~10)</div>
    <div class="aff" aria-label="호감도 게이지"><span id="affBar"></span></div>
    <div id="levelText" class="hint">현재 단계 계산 중…</div>
    <div class="hint" style="margin-top:6px">※ 장면/선택에 따라 레벨이 오르내립니다.</div>
  </aside>
</div>

<!-- =====================
  ENGINE (UI/로직) — 시나리오(JSON)는 별도
====================== -->
<script>
const Engine = (()=> {
  const state = { aff:0, speed:24, isTyping:false, skipTyping:false, currentLabel:'', script:null };
  const $log = document.getElementById('log');
  const $aff = document.getElementById('affBar');
  const $levelText = document.getElementById('levelText');

  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
  function scrollBottom(){ $log.scrollTop = $log.scrollHeight; }

  // 스킨십 레벨 계산(0~10) & 설명 문구
  function skinshipLevel(aff){
    const lvl = Math.max(0, Math.min(10, Math.floor((aff + 10) / 3))); // 대략 aff 20대 → 10레벨
    const table = {
      0: "거리 유지만 허용",
      1: "대화만 허용",
      2: "가벼운 아이컨택까지",
      3: "짧은 인사/하이파이브까지",
      4: "잠깐 손등 스침까지",
      5: "손잡기 허용",
      6: "팔짱까지 허용",
      7: "어깨 기대기까지 허용",
      8: "가벼운 포옹 허용",
      9: "포옹 + 이마 키스까지",
      10:"서로 합의된 키스까지"
    };
    return { lvl, desc: table[lvl] };
  }

  function renderAff(){
    const pct = Math.max(0, Math.min(100, state.aff));
    $aff.style.width = pct + '%';
    const { lvl, desc } = skinshipLevel(state.aff);
    $levelText.textContent = `레벨 ${lvl} — ${desc}`;
  }

  async function typeText(text, el){
    state.isTyping = true; el.textContent = '';
    for(let i=0;i<text.length;i++){
      if(state.skipTyping){ el.textContent = text; break; }
      el.textContent += text[i];
      if(state.speed>0) await sleep(state.speed);
    }
    state.isTyping = false; state.skipTyping = false;
  }

  function addLine(who, isNarr=false){
    const line = document.createElement('div'); line.className = 'line';
    const sp = document.createElement('div'); sp.className = 'speaker'; sp.textContent = isNarr ? '' : (who || '');
    const ct = document.createElement('div'); ct.className = 'content' + (isNarr ? ' narr' : '');
    line.appendChild(sp); line.appendChild(ct); $log.appendChild(line); scrollBottom();
    return ct;
  }

  // 대사 출력 + (지문)은 별도 내레이션 라인으로 괄호 처리
  async function showLine(who, text, psych){
    const ct = addLine(who);
    await typeText(text, ct);
    if (psych){
      const narr = addLine('', true);
      await typeText(`(${psych})`, narr);
    }
    // ▶ 다음 버튼 제거: 1초 대기 후 자동 진행
    await sleep(1000);
  }

  // 새로 추가: 소설식 배경 설명 전용 스텝
  async function showNarration(text){
    const narr = addLine('', true);
    await typeText(text, narr);
    await sleep(800); // 배경문은 살짝 빠르게 넘어감
  }

  // 선택지: 호감도 힌트/토스트 없이, 선택 후 감정변화 지문 출력
  function showChoices(options){
    return new Promise(resolve=>{
      const wrap = document.createElement('div'); wrap.className = 'choices';
      options.forEach(opt=>{
        const b = document.createElement('button'); b.className='choice';
        b.textContent = opt.text; // 힌트 제거
        b.addEventListener('click', async ()=>{
          wrap.querySelectorAll('button').forEach(x=>x.disabled=true);

          let delta = 0;
          if (typeof opt.affDelta === 'number'){
            delta = opt.affDelta;
            state.aff += delta;
            renderAff();
          }

          // 선택 직후 감정 변화 지문
          const narr = addLine('', true);
          const emo =
            delta >= 2 ? "수연의 눈빛이 확연히 부드러워진다." :
            delta === 1 ? "수연의 표정이 살짝 풀린다." :
            delta === 0 ? "수연의 표정엔 뚜렷한 변화가 없다." :
            delta <= -2 ? "수연의 표정이 잠시 굳는다." :
                          "수연의 미간이 살짝 좁혀진다.";
          await typeText(`(${emo})`, narr);

          // 약간의 텀 후 다음 라벨로 이동
          await sleep(400);
          resolve(opt.next);
          wrap.remove();
        });
        wrap.appendChild(b);
      });
      $log.appendChild(wrap); scrollBottom();
    });
  }

  async function runLabel(label){
    state.currentLabel = label;
    // 호환: {label:[...]} 또는 {label:{steps:[...]}}
    const node = state.script?.[label];
    const seq = Array.isArray(node) ? node : node?.steps;
    if(!seq){ info(`라벨이 없어요: ${label}`); return; }

    for(let i=0;i<seq.length;i++){
      const step = seq[i];
      if(step.type==='line'){
        await showLine(step.who||'', step.text||'', step.psych||'');
      }else if(step.type==='narration' || step.type==='narr'){
        await showNarration(step.text||'');
      }else if(step.type==='choice'){
        const next = await showChoices(step.options||[]);
        if(next){ await runLabel(next); return; }
      }else if(step.type==='branch'){
        const pass = (state.aff >= (step.cond?.affGTE ?? 0));
        const dest = pass ? step.then : step.else;
        await runLabel(dest); return;
      }else if(step.type==='goto'){
        await runLabel(step.next); return;
      }
    }
  }

  function info(msg){
    const ct = addLine('', true); ct.textContent = msg;
  }

  function detectStartLabel(script){
    if(script['E1'] || script?.E1?.steps) return 'E1';
    if(script['START'] || script?.START?.steps) return 'START';
    const keys = Object.keys(script||{});
    return keys.length ? keys[0] : null;
  }

  function replaceScenario(newScript){
    state.script = newScript || {};
    $log.innerHTML = '';
    state.aff = 0; renderAff();
    const start = detectStartLabel(state.script);
    if(start){
      runLabel(start);
    }else{
      info('시나리오 시작 라벨을 찾지 못했습니다. "E1" 또는 "START"를 추가하세요.');
    }
  }

  function hook(){
    document.getElementById('fast').addEventListener('click',()=>{
      state.speed = state.speed===0?24:0;
    });
    document.getElementById('restart').addEventListener('click',()=>{
      $log.innerHTML=''; state.aff=0; renderAff();
      const start = detectStartLabel(state.script); if(start) runLabel(start); else info('시작 라벨이 없습니다.');
    });
    document.getElementById('log').addEventListener('click',()=>{
      if(state.isTyping) state.skipTyping = true; // 클릭 시 타자기 즉시 스킵
    });

    // 파일 업로드 JSON
    const fileInput = document.getElementById('file');
    fileInput.addEventListener('change', (e)=>{
      const f=e.target.files?.[0]; if(!f) return;
      const reader=new FileReader();
      reader.onload=()=>{
        try{ const data=JSON.parse(reader.result); replaceScenario(data); }
        catch(err){ alert('JSON 파싱 실패: '+err.message); }
      };
      reader.readAsText(f,'utf-8');
    });
  }

  return {replaceScenario, hook, info, renderAff};
})();
</script>

<!-- =====================
  BOOTSTRAP — 외부 JSON 시도 → 실패 시 업로드 안내
====================== -->
<script>
(async function boot(){
  Engine.hook();
  Engine.renderAff();

  // 같은 폴더의 scenario.json 자동 로딩 시도
  try{
    const resp = await fetch('scenario.json', {cache:'no-store'});
    if(resp.ok){
      const data = await resp.json();
      Engine.replaceScenario(data);
      return;
    }else{
      Engine.info('같은 폴더에 <scenario.json>이 없습니다. 상단 버튼으로 JSON을 불러오세요.');
    }
  }catch(e){
    Engine.info('자동 로딩 실패. 상단 버튼으로 JSON을 불러오세요.');
  }
})();
</script>
</body>
</html>
